package html

import (
	"fmt"

	"gitlab.com/sacules/chartsy/internal/models"
)

script chartRender(currentChart *models.Chart) {
	const sizeMultiplier = 8;

	const width = currentChart.ImagesSize * currentChart.ColumnCount + (currentChart.Spacing * sizeMultiplier) * (currentChart.ColumnCount - 1) + (currentChart.Padding * sizeMultiplier) * 2;
	const height = currentChart.ImagesSize * currentChart.RowCount + (currentChart.Spacing * sizeMultiplier) * (currentChart.RowCount - 1) + (currentChart.Padding * sizeMultiplier) * 2;

	const stage = new Konva.Stage({
	  container: 'chart',
	  width,
	  height,
	});

	const layer = new Konva.Layer();
	const tempLayer = new Konva.Layer();

	const totalImgs = currentChart.ColumnCount * currentChart.RowCount;

	for (let i = 0; i < currentChart.RowCount; i++) {
		for (let j = 0; j < currentChart.ColumnCount; j++) {
			const imgSize = currentChart.ImagesSize;

			let x = (j % currentChart.ColumnCount) * imgSize + currentChart.Padding * sizeMultiplier;
			if (j > 0) {
				x += currentChart.Spacing * sizeMultiplier * j; // Equivalent to 1rem most of the time
			}

			let y = (i % currentChart.RowCount) * imgSize + currentChart.Padding * sizeMultiplier;
			if (i > 0) {
				y += currentChart.Spacing * sizeMultiplier * i; // Equivalent to 1rem most of the time
			}

			const image = new Image();
			image.onload = () => {
				const cover = new Konva.Image({
				  x,
				  y,
				  width: imgSize,
				  height: imgSize,
				  image,
				  name: ((i+1)*(j+1)) + ". " + currentChart.Images[i * j].Title + " - " + currentChart.Images[i * j].Caption,
				  stroke: 'cyan',
				  draggable: true,
				  strokeWidth: 4,
				  strokeEnabled: false,
				});

				cover.on("mouseover", e => {
					const img = e.target;
					document.body.style.cursor = "grab";
					img.strokeEnabled(true);
				});

				cover.on("mouseout", e => {
					const img = e.target;
					document.body.style.cursor = "default";
					img.strokeEnabled(false);
				});

				cover.on("dragenter", e => {
					e.target.strokeEnabled(false);
				})

				layer.add(cover);
			};
			image.src = currentChart.Images[i * j].URL;
		}
	}

	const text = new Konva.Text({
		fill: "black",
	});
	layer.add(text);

	stage.add(layer);
	stage.add(tempLayer);

	stage.on("dragstart", e => {
		e.target.moveTo(tempLayer);
		layer.draw();
		text.text("moving " + e.target.name());
	});

	let previousImg;
	stage.on("dragmove", e => {
		const pos = stage.getPointerPosition();
		const img = layer.getIntersection(pos);
		if (previousImg && img) {
			if (previousImg === img) {
				previousImg.fire("dragover", { evt: e.evt }, true);
				return;
			}

			// leave old target
			previousImg.fire("dragleave", { evt: e.evt }, true);

			// enter new one
			img.fire("dragenter", { evt: e.evt }, true);
			return;
		}

		if (!previousImg && img) {
			previousImg = img;
			img.fire("dragenter", { evt: e.evt }, true);
		}

		if (previousImg && !img) {
			previousImg.fire("dragleave", { evt: e.evt }, true);
			previousImg = undefined;
		}

		document.body.style.cursor = "grab";
	});

	stage.on("dragend", e => {
		const pos = stage.getPointerPosition();
		const img = layer.getIntersection(pos);

		if (img) {
			previousImg.fire("drop", { evt: e.evt }, true);
			previousImg = undefined;
			e.target.moveTo(layer);
		}
	});

	 stage.on('dragenter', e => {
        e.target.stroke('green');
		e.target.strokeEnabled(true);
        text.text('dragenter ' + e.target.name());
      });

      stage.on('dragleave', e => {
        e.target.stroke('blue');
		e.target.strokeEnabled(true);
        text.text('dragleave ' + e.target.name());
      });

      stage.on('dragover', e => {
		e.target.strokeEnabled(true);
        text.text('dragover ' + e.target.name());
      });

      stage.on('drop', e => {
        e.target.stroke('red');
		e.target.strokeEnabled(true);
        text.text('drop ' + e.target.name());
      });
}

templ ChartCanvas(currentChart *models.Chart) {
	<div id="chart" class="bg-slate-200">
	</div>
}

templ Chart(isAuthenticated bool, currentChart *models.Chart) {
	if currentChart != nil {
		<div
			_="def updateChart()
				   get the getComputedStyle(me) then set computedStyles to it
				   set cols to computedStyles.getPropertyValue('--chart-settings-cols')
				   set rows to computedStyles.getPropertyValue('--chart-settings-rows')

				   set total to rows * cols

				   set images to the children of #images
				   for img in images index i
					   if i >= total
						   set img's @aria-hidden to true
					   else
						   set img's @aria-hidden to false
					   end
				   end

				   set #text's @rows to rows
				   set #text's @columns to cols
			   end

			   init
				   updateChart()
				   show me
			   end

			   -- mobile replace on search
			   on chartImages(src, title, caption)
				   set imgs to the children of #images
				   set imgTxt to the children of #text
				   send replace(src: src, title: title, caption: caption) to imgs[$replaceIndex]
			   end

			   on chartUpdate
				   updateChart()
			   end

			   on chartTextPlacement(value)
				   if value is 'hide' or value is 'inline' or value is 'overlay'
					   set <chart-image/>'s @text-placement to value
					   add [@text-placement=hide] to #images-text
				   end
				   if value is 'left' or value is 'below' or value is 'right'
					   set #images-text's @text-placement to value
					   add [@text-placement=hide] to <chart-image/>
				   end
			   end

			   on chartImagesShape(value)
				   set <chart-image/>'s @shape to value
			   end"
			id="chart"
			style="display: none;"
			class="slide-it"
		>
			<chart-images-text
				_="on bgChange(state)
				   if state is 'color'
				       remove .gradient from me
				       remove .image from me
					   add .color to me
				   end
				   if state is 'gradient'
				       remove .color from me
				       remove .image from me
					   add .gradient to me
				   end
				   if state is 'image'
				       remove .color from me
				       remove .gradient from me
					   add .image to me
				   end
			   on bgChangeColor(value)
				   call #chart.style.setProperty('--chart-settings-background-color', value)
			   on bgChangeGradientFrom(value)
				   call #chart.style.setProperty('--chart-settings-background-gradient-from', value)
			   on bgChangeGradientTo(value)
				   call #chart.style.setProperty('--chart-settings-background-gradient-to', value)
			   on bgChangeImage(file)
			       set src to URL.createObjectURL(file)
			       set url to `url('${src}')`
				   call #chart.style.setProperty('--chart-settings-background-image', url)"
				id="images-text"
				text-placement="hide"
				chart-title={ currentChart.Title }
				class="grid bg-cover bg-center color"
			>
				<ul
					_="init
					   call prepareChart(me)
					   send chart:update(images: me) to #text
				   end
				   on drop(target)
					   send chart:update(images: me) to #text

				   -- sortable events
				   on move(dragged)
					   send chart:update(images: me) to #text
				       set the dragged's @data-was-dragging to true
				   on update(item, newIndex)
				       set images to the children of me
					   for img in images index i
						   set the img's @index to i
					   end
				   on end(item)
					   set the item's @data-was-dragging to false"
					if isAuthenticated {
						hx-patch="/images"
						hx-trigger="update delay:300ms, drop"
						hx-include="#chart-id,chart-image[aria-hidden=false]"
					}
					id="images"
					class="grid"
					slot="images"
				>
					for i, v := range currentChart.Images {
						<chart-image
							_="on touchend
							   if @data-was-dragging
								   remove @data-was-dragging from me
								   exit
							   end
							   wait 150ms -- helps make things feel smooth
							   toggle between .hidden and .block on <footer/>
							   set $replaceIndex to my.index
							   send open to #search-mobile
							   call history.pushState('search-mobile-open', null, 'search-mobile')
							end"
							class="aria-hidden:hidden sortable-item"
							index={ fmt.Sprint(i) }
							title={ v.Title }
							caption={ v.Caption }
							src={ v.URL }
							text-color={ currentChart.TextColor }
							text-placement="hide"
							shape={ string(currentChart.ImagesShape) }
							aria-hidden="true"
						>
							<input slot="title" type="text" value={ v.Title } hidden autocomplete="off"/>
							<input slot="caption" type="text" value={ v.Caption } hidden autocomplete="off"/>
							<input slot="url" type="text" value={ v.URL } hidden autocomplete="off"/>
						</chart-image>
					}
				</ul>
				@ChartText(currentChart.Images)
				<input id="chart-id" type="number" name="id" value={ fmt.Sprint(currentChart.ID) }/>
			</chart-images-text>
		</div>
	}
}

templ ChartText(imgs []models.Image) {
	<ul
		_="on chart:update(images)
			  set total to @rows * @columns
			  set titles to my children
			  for img in images.children index i
			    set t to titles[i]
				put img's caption into the <strong/> in t
				put img's title into the <span/> in t
				if i >= total then
				  set t's @aria-hidden to true
				else
				  set t's @aria-hidden to false
				end
			  end"
		id="text"
		class="px-4 w-max"
		slot="text"
	>
		for i, img := range imgs {
			<li class="aria-hidden:hidden text-slate-900" index={fmt.Sprint(i)} aria-hidden="true">
				<strong>{img.Caption}</strong>
				<span>{img.Title}</span>
			</li>
		}
	</ul>
}
